## kaspersky-counter

Используя только средства стандартной библиотеки, разработать HTTP-сервер. Сервер должен:

* На каждый запрос возвращать значение счетчика, считающего общее количество обработанных сервером запросов за последние 60 секунд;
* Продолжать возвращать корректное значение счетчика после перезапуска приложения используя персистентное хранилище.

#### Ожидается:

* Аккуратный, хорошо-структурированный код с применением устоявшихся т.н. best practices
* Документирование кода в местах на усмотрение автора

#### Будет плюсом:

* Тесты
* Готовый, к деплою на production-стенд, код
* Использование Docker
* Комментарии, почему было выбрано то или иное решение

## Комментарии

У меня не слишком много опыта работы с Go, поэтому ряд решений может оказаться спорным или ошибочным.
Будет здорово получить по ним фидбек и поговорить про объектную модель в Go, в том числе про применимость к ней практик из ООП-мира вроде DDD и Event Sourcing.

#### Конфигурация через environment variables.
Насколько я понимаю в Golang для конфигурации используются переменные окружения или аргументы. В некоторых решениях я видел более динамические решения, вплоть до ini-файлов, но не уверен, что это правильно.

#### Глобальный обработчик 
В метод http.ListenAndServe() передается структура для обработки всех запросов к сервису. Насколько мне известно, это далеко не best practices и если бы задание не указывало на единый endpoint сервиса, то я предпочел бы использовать http.HandleFunc()

#### Инициализация пакетов.
После C#/Java и конструкторов не совсем понятно, как правильно инициализации пакеты, если туда необходимо передать аргументы из main.
Я использовал функцию LoadState(someArgsHere) сервиса, для приложения это нормальные, но если бы я работал над библиотекой очередность вызова метода была бы неочевиден для пользователей.
init(), к сожалению, для этого не подходит

#### Персистентное хранение
В задачке предложено пользоваться персистентным хранилищем используя стандартную библиотеку, что сразу исключило использование СУБД. Мне показалось оптимальным хранить данные в gob-формате.
Если бы можно было обойтись in-memory хранением, то вместо дорогостоящей блокировки sync.Mutex был бы использован lock-free пакет atomic для cas-инкремента. 

#### Прочее
По сервисам, что я видел, было заметно, что в Go не популярен маппинг моделей (+разделение их на domain/view/input) и fail fast подход к проверке предусловий используется крайне редко.
Но в некоторых местах мне показалось это необходимым.